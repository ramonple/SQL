IMPORTANT: How to get the cumulative sum? -- > 534,571. a. wind function SUM b. Self-Join
                                              a. SUM (column name) OVER (partition by. order by)
                                              b. select xxx from table t1, table t2 ON t1.id=t2.id AND t1.id>=t2.id
           How to find the median value? 569, 571 (please refer to the end)


511 Game Play Analysis I [Easy]
Write an SQL query that reports the first login date for each player.

- know we can directly use Min(Date()),Max(Date())

select player_id, Min( Date(event_date)) As first_login
from Activity
Group by player_id


512 Game Play Analysis II [Easy]
Write a SQL query that reports the device that is first logged in for each player.

My way:
select player_id, device_id
from activity
where (player_id,event_date) IN (
select player_id, Min(date(event_date)) As first_login
from activity
group by player_id );

We can also use the window functio

select player_id,device_id
from (select player_id, device_id, Rank () Over (partition by player_id Order by event_date) As firstDay
from activity ) as a
where firstDay = 1


534 Game Play Analysis III [Medium]
-- Write an SQL query that reports for each player and date, how many games played so far by the player. 
-- That is, the total number of games played by the player until that date. Check the example for clarity.

-- importance!! how to understand this question. It is asking for the cummulative time.

a. To calculate the cummulative sum, Using Sum () Function with Over () Clause :
select player_id,event_date,sum(games) Over (partition by player_id order by event_date) as game_played_so_far
from activity

b. Using sel-join
select a.player_id, a.event_date,sum(b.games)
from activity a join activity b
on a.player_id = b.player_id
where a.event_date >= b.event_date
group by a.player_id, a.event_date
order by a.player_id;

550 Game Play Analysis IV [Medium]
Write an SQL query that reports the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. 
In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, 
then divide that number by the total number of players.

a. -- aggreate function and group 
  -- similar to my idea, we first find the first login date of each player and then check whether they log in on the following day
SELECT ROUND(COUNT(DISTINCT b.player_id)/COUNT(DISTINCT a.player_id), 2) AS fraction 
FROM Activity AS a LEFT JOIN (SELECT player_id, MIN(event_date) AS first_login FROM Activity GROUP BY player_id) AS b
ON a.player_id = b.player_id
AND DATEDIFF(a.event_date, b.first_login) = 1 ## can also use DATE_ADD(b.first_login,INTERVAL 1 DAY) = a.event_date

b. -- FIRST_VALUE() Window Function. (not use MIN but the FIRST_VALUE window function).  ## First_Value(column name) OVER (partition by order by)
SELECT ROUND(COUNT(DISTINCT b.player_id)/COUNT(DISTINCT a.player_id), 2) AS fraction FROM Activity AS a
LEFT JOIN
(SELECT player_id, FIRST_VALUE(event_date) OVER(PARTITION BY player_id ORDER BY event_date) AS first_login FROM Activity) AS b
ON a.player_id = b.player_id
AND DATEDIFF(a.event_date, b.first_login) = 1. 

569 Median Employee Salary [Hard]
!!! how to find the median
-- when there is n of values in total, the median should be 
-- n is odd, median = (n+1)/2 th observation
-- n is even median = 1/2 (n/2 th observation + (n/2 + 1)th obervation)

-- so if when we have the rank
-- we should find the rank of the median
-- if intotal there are n values, the median should be Where n/2 <= THIS <= n/2 + 1;
-- OR  -- where rno in (ceil(cnt/2), cnt/2 + 1);

select id, company, salary
from
(
  select id, company, salary, 
         row_number() over(partition by company order by salary) as rno, -- the rank of each salary in each company
         count(*) over(partition by company) as cnt -- how many staff in each company
  from Employee
) x
WHERE (cnt/2) <= rno AND rno<= (cnt/2) + 1;  -- where rno in (ceil(cnt/2), cnt/2 + 1)


-- 570. Managers with at Least 5 Direct Reports

select name
from employee
where id IN
(select managerid from employee 
group by managerid
Having count(managerID) >= 5 )

-- 571 Find Median Given Frequency of Numbers [Hard]
  -- QUESTION: How to get the cummulative sum?

SELECT  AVG(Number) AS median
From
(select *, SUM(Frequency) OVER (ORDER BY Number) AS cum_sum, 
          (sum(frequency) Over () / 2) As mid
FROM Numbers ) as T

Where mid BETWEEN cum_sum - frequency AND cum_sum;
-- cum_sum caculate the number is from which position
-- 5<= mid <= 9, the corresponding number starts from 5th and ends at 9th
-- Use Average to deal with the condition when the number of numbers is event. the median should be 1/2 (x1+x2)


---------------------------How to get the median in SQL-----------------------------------

a. ( Max of Bottom Half + Min of Top Half ) / 2

SELECT
(
 (SELECT MAX(Score) FROM
   (SELECT TOP 50 PERCENT Score FROM Posts ORDER BY Score) AS BottomHalf)
 +
 (SELECT MIN(Score) FROM
   (SELECT TOP 50 PERCENT Score FROM Posts ORDER BY Score DESC) AS TopHalf)
) / 2 AS Median

-- asscending order: upper 50%. -> The maximum of the Bottom Half
-- descending order: upper 50%. -> The minimum of the Top Half

b. RANK 
Rank the corresponding the values in the column as 'RANK'
calculate how many numbers are there in total as 'Total'
We want     Total/ 2 <= RANK <= Total/2 + 1. OR RANK IN (ceil(Total/2), Total/2 + 1)

------- Use Frequency to find the median
a. calculate the cummulative frequency As 'cum_fre'
b. find the mid postion -> Sum(frequency) / 2 AS 'mid'
Where mid BETWEEN cum_fre - fre AND cum_fre

----------------------------------------------------------------------------------

574 Winning Candidate [Medium]

-- problem is how to read the vote table. id is the one who votes, and candidate id is the one who gets the vote.
-- for example, id=1 votes to candidate 2.

-- approach 1
Select Name
From Candidate JOIN
(select CandidateId, COUNT(*)
From VOTE
group by CandidateID
Order by COUNT(*) DESC
LIMIT 1 ) As A
ON Candidate.id=A.candidateid

-- approach 2
select Name
From Candidate
WHere id =
(select CandidateId
From VOTE
group by CandidateID
Order by COUNT(*) DESC
LIMIT 1 )


-- 577 Employee Bonus [Easy]
-- Select all employee's name and bonus whose bonus is < 1000.
select employee.name,bonus.bonus
from Employee LEFT JOIN bonus ON employee.empid=bonus.empId
where employee.empid NOT IN (
select empid from Bonus
where bonus >= 1000);

-- Not sure what I am doing here is correct or not. OR I need to let SQL to output null if there doesn't exist the value.
a. 
select employee.name, IFNULL(bonus.bonus, null) As Bonus
from Employee LEFT JOIN bonus ON employee.empid=bonus.empId
where employee.empid NOT IN (
select empid from Bonus
where bonus >= 1000);

b. 
SELECT a.name, 
b.bonus
FROM Employee AS a
LEFT JOIN Bonus AS b
ON a.empId = b.empId
WHERE b.bonus < 1000 OR b.bonus IS NULL; -- different idea. Here it want to find the id whether with bonous < 1000 Or NULL


-- 578 Get Highest Answer Rate Question [Medium]
Write a sql query to identify the question which has the highest answer rate.
Note:The highest answer rate meaning is: answer number's ratio in show number in the same question.

-- approach 1
SELECT question_id AS 'survey_log' -- Leetcode asks for the column name 'survey_log'
FROM survey_log
GROUP BY question_id
ORDER BY COUNT(answer_id)/ COUNT(IF(action = 'show', 1, NULL)) DESC.  -- clever approach to calculate how many times this question has been answered
LIMIT 1;
OR 
select question_id as 'survery_log'
from survey_log
group by question_id
Order by COUNT(answer_id) / SUM(CASE WHEN action = 'show' THEN 1 ELSE 0 END) DESC
LIMIT 1

-- approach 2
SELECT question_id AS survey_log
FROM
(SELECT question_id,
        SUM(case when action="answer" THEN 1 ELSE 0 END) AS num_answer,
        SUM(case when action="show" THEN 1 ELSE 0 END) AS num_show  
	FROM survey_log
	GROUP BY question_id
) AS tbl
ORDER BY (num_answer / num_show) DESC
LIMIT 1

-- TAKE AWAY: two approaches to find the percentage; Use LIMIT 1 to find the MIN or MAX (with desc)



579 Find Cumulative Salary of an Employee [Hard]

-- Write a SQL to get the cumulative sum of an employee's salary over a period of 3 months but exclude the most recent month.
-- The result should be displayed by 'Id' ascending, and then by 'Month' descending.

SELECT E1.id, E1.month,
(IFNULL(E1.salary, 0) + IFNULL(E2.salary, 0) + IFNULL(E3.salary, 0)) AS Salary
FROM
(
SELECT id, MAX(month) AS month FROM Employee
GROUP BY id
HAVING COUNT(*) > 1
) AS maxmonth
LEFT JOIN Employee AS E1 
ON (maxmonth.id = E1.id AND maxmonth.month > E1.month). -- E1 includes everthing expect the latest month (what we want to delete)
LEFT JOIN Employee AS E2 
ON (E2.id = E1.id AND E2.month = E1.month - 1)
LEFT JOIN Employee AS E3 
ON (E3.id = E1.id AND E3.month = E1.month - 2)
ORDER BY id ASC, month DESC;

-- why we should use left join?
-- first, we find the payment of latest month of each employee. For example, this month is April, and we have 3 employees,
--  they are a,b,and c. For a, the lastest is 4 (april), for B is 3 (march) and 2 (Feb) for c.
--  If this is the case, for a we should ignore the payment made in april. However, we cannot do this for b and c. As they
-- do not get payment on the lasest month. Thus, we should keep all of them => That is why we should use LEFT JOIN

- Classical approach to calculate the cummulative sth is the SELF JOIN (which is shown as LEFT JOIN here)
- we only need to consider the magnitude relationship, e.g., a.id = b.id AND a.month=b.month+1



580 Count Student Number in Departments [Medium]








