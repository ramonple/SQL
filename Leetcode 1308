-- 138. SQL 计算累计和 sum() over( partition by order by )
         for more details: https://www.cnblogs.com/mingdashu/p/12100734.html

-- 1321: Moving Average
         ROWS PRECEDING and ROWS FOLLOWING
         Preceding refers to rows before the current row, where the following argument refers to rows after the current row. 
         e.g., ROWS BETWEEN 3 preceding and current row - looks at three rows above the current row and current row -- MUST first 3 proceding and then current row


1308. Running Total for Different Genders [Medium]
-- Write an SQL query to find the total score for each gender at each day.
-- Order the result table by gender and day

select gender, day, SUM(score_points) OVER(PARTITION BY gender ORDER BY day) AS total -- why need the partition by? Cummulative sum
from scores 
group by day, gender
order by gender, day

-- problem with mistakes. According to the answer, it should be a cummulative score for each gender until that day.



-- 1321. Restaurant Growth [Medium]
-- You are the restaurant owner and you want to analyze a possible expansion (there will be at least one customer every day).
-- Write an SQL query to compute moving average of how much customer paid in a 7 days window (current day + 6 days before) .
-- Return result table ordered by visited_on.
-- average_amount should be rounded to 2 decimal places, all dates are in the format ('YYYY-MM-DD').

-- confused -- needs to really understand the requirement of this question
-- compute moving average of how much customer paid in a 7 days window ???!!!
WITH t AS
(
SELECT visited_on, 
ROW_NUMBER() OVER(ORDER BY visited_on) AS rn,
SUM(SUM(amount)) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND current row) AS amount
FROM Customer
GROUP BY visited_on
)

SELECT visited_on, amount, ROUND(amount/7,2) AS average_amount
FROM t
WHERE rn >= 7;

-- notice, there are more than one customers on 2019-01-10. 
-- if we direcly use sum, we will have two columns, it should be SUM( SUM(amount) )
-- ROW 6 PRECEDING

-- self join approach
select a.visited_on, 
    sum(b.amount) amount,
    round(sum(b.amount)/7,2) average_amount
from (select visited_on, sum(amount) amount from Customer GROUP BY visited_on) a, 
    (select visited_on, sum(amount) amount from Customer GROUP BY visited_on) b 
where datediff(a.visited_on,b.visited_on) between 0 and 6
group by a.visited_on
having count(distinct b.visited_on) = 7;



1322. Ads Performance [Easy]
-- A company is running Ads and wants to calculate the performance of each Ad.
-- Performance of the Ad is measured using Click-Through Rate (CTR) where:
-- Write an SQL query to find the ctr of each Ad.

select t.ad_id, IFNULL( ROUND(a.clicktime/b.totalTime,2),0) as ctr
from 
(select ad_id from Ads group by ad_id) as t
LEFT JOIN
( select ad_id, IFNULL(count(ad_id),0) as clicktime
from Ads
where action = 'Clicked'
group by ad_id) as a ON t.ad_id = a.ad_id
JOIN
( select ad_id, count(ad_id) as totalTime
from Ads
where action = 'Clicked' OR action = 'Viewed'
group by ad_id) as b
On a.ad_id = b.ad_id
order by ctr DESC, ad_id
-- WRONG!!! ad = 5 has 0 viewed + click. it is ignored

should use CASE WHEN:

SELECT ad_id,
CASE WHEN
SUM(CASE WHEN action IN ('Clicked', 'Viewed') THEN 1 ELSE 0 END) = 0 THEN 0
ELSE
ROUND(100 * SUM(CASE WHEN action = 'Clicked' Then 1 ELSE 0 END)/SUM(CASE WHEN action IN ('Clicked', 'Viewed') THEN 1 ELSE 0 END),2) 
END AS ctr
FROM Ads
GROUP BY ad_id
ORDER BY ctr DESC, ad_id;


select ad_id, (case when total = 0 THEN 0 ELSE  round(clocks*100/total,2) end) as ctr
from
(
select ad_id,
sum( CASE WHEN action = 'Clicked' then 1 else 0 end ) as clocks,
sum(CASE WHen action IN ('Clicked','Viewed') Then 1 else 0 end) as total
from Ads
group by ad_id ) as a
order by ctr desc, ad_id asc



-- 1327. List the Products Ordered in a Period [Easy]
-- Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.
select products.product_name, sum(orders.unit) as amount
from products JOIN orders
     ON products.product_id = orders.product_id
where order_date BETWEEN '2020-02-01' AND '2020-02-29'
group by products.product_name
Having amount>= 100




-- 1336. Number of Transactions per Visit [Hard]
-- transaction_count 是一次访问完成的交易数，取值区间为 0 至 一个或多个用户完成最多交易数（transactions_count）
-- visits_count 是一次访问银行交易次数为 transaction_count 的用户数。

-- A bank wants to draw a chart of the number of transactions bank visitors did in one visit to the bank 
-- and the corresponding number of visitors who have done this number of transaction in one visit.
-- Write an SQL query to find how many users visited the bank and didn't do any transactions, how many visited the bank and did one transaction and so on.

-- The result table will contain two columns:

-- transaction_count which is the number of transactions done in one visit.
-- visits_count which is the corresponding number of users who did transaction_count in one visit to the bank.
-- transaction_count should take all values from 0 to max(transaction_count) done by one or more users.

-- Order the result table by transaction_count.
select a.transaction_count, count(transaction_count) as visits_count
from 
(select v.user_id, v.visit_date,count(t.transaction_date) as transaction_count
from Visits as v LEFT JOIN transactions as t
     ON v.user_id = t.user_id AND v.visit_date = t.transaction_date
group by v.user_id,v.visit_date) as a
group by transaction_count

-- WRONG !! MISSTING TWO:
-- leetcode

WITH 
continuous AS (
SELECT ROW_NUMBER() OVER() AS transactions_count FROM Transactions
UNION 
SELECT 0 AS transactions_count
), -- how many transactions can we have. from 0 to the maximum row number of transaction

trans AS (
SELECT a.user_id, a.visit_date, 
IFNULL(COUNT(amount) OVER(PARTITION BY a.user_id, a.visit_date), 0) AS transactions_count
FROM Visits AS a
LEFT JOIN Transactions AS b
ON a.user_id = b.user_id AND a.visit_date = b.transaction_date
) -- how many transactions each user on each vist -- the one I obtained above

SELECT b.transactions_count, IFNULL(COUNT(DISTINCT a.user_id, a.visit_date), 0) AS visits_count
FROM trans AS a 
RIGHT JOIN continuous AS b
ON a.transactions_count = b.transactions_count
GROUP BY b.transactions_count
HAVING b.transactions_count <= (SELECT MAX(transactions_count) FROM trans)
ORDER BY 1;

-- here, we should focus on two essential points
-- a. when there is no transacions (have noticed)
-- b. during min ( transaction time) to max (transaction time), a internal time is skipped (haven't noticed)!!
    --> the  0<= possible transaction numbers <= row number of transation table 


