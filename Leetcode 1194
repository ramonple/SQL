
-- 1204 a. SUM() OVER (partition by ... order by ...)
        b. In With .. as ,.. as caluse, the second one can directly use the first one !!!
           With tmp as (), tmp1 as (select xxx from tmp )
        c. how to use "rank number' to determine the one satisfies the condition
        
        
        
        
        

-- 1194. Tournament Winners [Hard]

-- The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins.

-- Write an SQL query to find the winner in each group.

-- my code: cannot run
select  match_id, ( case when first_score > second_score then first_player 
              when first_score < second_score then second_player
						 else min(first_player,second_player) end ) as player_id
from matches
group by match_id

-- we need to focus on the sum scores of each player, instead of in each match

-- leetcode:
SELECT group_id, player_id FROM (
SELECT a.group_id, a.player_id,
ROW_NUMBER() OVER(PARTITION BY a.group_id ORDER BY IFNULL(b.score,0) DESC, a.player_id) AS rnk
FROM Players AS a
LEFT JOIN (
SELECT player_id, SUM(score) AS score FROM (
SELECT match_id, first_player AS player_id, first_score AS score
FROM Matches
UNION ALL
SELECT match_id, second_player AS player_id, second_score AS score
FROM Matches
) AS x
GROUP BY player_id
) AS b
ON a.player_id = b.player_id
) AS tmp
WHERE rnk = 1;

-- split the answer:

select a.*,b.*
from
players as a
LEFT JOIN
( select player_id, sum(score) as score
from 
(select match_id,first_player as player_id,first_score as score
from matches
UNION all  -- does no delete the duplications
select match_id, second_player as player_id, second_score as score
from matches ) as x
group by player_id ) as b
ON a.player_id = b.player_id

-- out out the corresponding score of each player, and the player's corresponding team
-- how to deal with the NULL?

select temp.group_id, temp.player_id
from (
select a.group_id, a.player_id, ROW_NUMBER() OVER(PARTITION BY a.group_id ORDER BY IFNULL(b.score,0) DESC, a.player_id) AS rnk -- IFNULL
from
players as a
LEFT JOIN
( select player_id, sum(score) as score
from 
(select match_id,first_player as player_id,first_score as score
from matches

UNION all  -- does no delete the duplications
select match_id, second_player as player_id, second_score as score
from matches ) as x
group by player_id ) as b
ON a.player_id = b.player_id ) as temp
where rnk = 1






-- 1204. Last Person to Fit in the Elevator [Medium]

-- The maximum weight the elevator can hold is 1000.

-- Write an SQL query to find the person_name of the last person who will fit in the elevator without exceeding the weight limit. 
-- It is guaranteed that the person who is first in the queue can fit in the elevator.


WITH
tmp AS (
SELECT person_id, person_name, weight, turn,
SUM(weight) OVER(ORDER BY turn ASC) AS cum_weight
FROM Queue
),
tmp1 AS (
SELECT person_name, turn, cum_weight FROM tmp
WHERE cum_weight <= 1000
)
SELECT person_name FROM tmp1
WHERE turn >= ALL(SELECT turn FROM tmp1);





-- 1205. Monthly Transactions II [Medium]


-- Write an SQL query to find for each month and country, the number of approved transactions and their total amount, 
-- the number of chargebacks and their total amount.

WITH
tmp AS (
SELECT a.trans_id AS id, b.country, 'checkback' AS state, b.amount, a.trans_date 
FROM Chargebacks AS a
LEFT JOIN Transactions AS b
ON a.trans_id = b.id

UNION ALL
    
SELECT * FROM Transactions
WHERE state = 'approved'
)

SELECT DATE_FORMAT(trans_date, "%Y-%m") AS month, country,
SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) AS approved_count,
SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_amount,
SUM(CASE WHEN state = 'checkback' THEN 1 ELSE 0 END) AS chargeback_count,
SUM(CASE WHEN state = 'checkback' THEN amount ELSE 0 END) AS chargeback_amount
FROM tmp
GROUP BY DATE_FORMAT(trans_date, "%Y-%m"), country;







-- 1211. Queries Quality and Percentage [Easy]
-- We define query quality as: The average of the ratio between query rating and its position.

-- We also define poor_query_percentage as: The percentage of all queries with rating less than 3.

-- Write an SQL query to find each query name, the quality and poor_query_percentage.

-- Both quality and poor_query_percentage should be rounded to 2 decimal places.
-- my code
select query_name,ROUND(  avg(rating/ position),2) as quality,
ROUND( (SUM(case when rating < 3 then 1 else 0 end)/count(rating) ) * 100, 2) as poor_query_percentage
from queries
group by query_name


-- leetcode
SELECT query_name,
ROUND(AVG(rating/position),2) AS quality,
ROUND(SUM(100 * CASE WHEN rating < 3 THEN 1 ELSE 0 END)/COUNT(DISTINCT result),2) AS poor_query_percentage
FROM Queries
GROUP BY query_name;


-- 1212. Team Scores in Football Tournament [Medium]

You would like to compute the scores of all teams after all matches. Points are awarded as follows:

A team receives three points if they win a match (Score strictly more goals than the opponent team).
A team receives one point if they draw a match (Same number of goals as the opponent team).
A team receives no points if they lose a match (Score less goals than the opponent team).
Write an SQL query that selects the team_id, team_name and num_points of each team in the tournament after all described matches. Result table should be ordered by num_points (decreasing order). In case of a tie, order the records by team_id (increasing order).

 -- summarize each match conclusion
( select 
( case when host_goals > guest_goals then host_team else null end) as hostwin,
( case when host_goals <  guest_goals then guest_team else null end) as gustwin,
( case when host_goals = guest_goals then host_team else null end) as amatch,
( case when host_goals = guest_goals then guest_team else null end) as bmatch
from matches ) as tmp

-- have no idea what is the next step

-- leetcode
SELECT a.team_id, a.team_name, IFNULL(b.score,0) AS num_points 
FROM Teams AS a
LEFT JOIN (
SELECT team, SUM(score) AS score
FROM (
SELECT match_id, host_team AS team,
CASE WHEN host_goals > guest_goals THEN 3 
WHEN host_goals = guest_goals THEN 1
ELSE 0 END AS score
FROM Matches
UNION ALL
SELECT match_id, guest_team AS team,
CASE WHEN guest_goals > host_goals THEN 3 
WHEN guest_goals = host_goals THEN 1
ELSE 0 END AS score
FROM Matches
) AS tmp
GROUP BY team
) AS b
ON a.team_id = b.team
ORDER BY num_points DESC, team_id;

-- we should summarize the score according to each match
-- add 3 scores for the winner of each match

select a.team_id,a.team_name,IFNULL( b.score,0) as num_points
from Teams as a 
LEFT JOIN 
(
select team, sum(score) as score
from
(
select match_id, host_team as team, 
       ( case when host_goals > guest_goals THEN 3 
            WHEN host_goals = guest_goals THEN 1
            ELSE 0 END) as score
from matches

UNION ALL

select match_id, guest_team as team, 
       ( case when host_goals < guest_goals THEN 3 
            WHEN host_goals = guest_goals THEN 1
            ELSE 0 END) as score
from matches
) as tmp  
group by team) as b
ON a.team_id = b.team
order by num_points DESC

-- one team, the one with zero score, disappeared -- IFNULL(b.score,0)
